"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveIdentifierName = exports.createTree = exports.INDEX = void 0;
const svgo_1 = require("svgo");
const path_1 = require("path");
const typescript_1 = require("typescript");
const fs_extra_1 = require("fs-extra");
const ast_1 = require("./ast");
const camelcase_1 = __importDefault(require("camelcase"));
const printer = (0, typescript_1.createPrinter)({
    newLine: typescript_1.NewLineKind.LineFeed,
});
const sourceFile = (0, typescript_1.createSourceFile)('generator.ts', '', typescript_1.ScriptTarget.Latest, false, typescript_1.ScriptKind.TS);
exports.INDEX = `__INDEX__`;
function createTree(srcPath, outputPath, config) {
    var _a, _b;
    const tree = [];
    const result = (0, fs_extra_1.readdirSync)(srcPath, { withFileTypes: true });
    const plugins = (_b = (_a = config.svgoConfig) === null || _a === void 0 ? void 0 : _a.plugins) !== null && _b !== void 0 ? _b : [];
    for (const file of result) {
        if (file.isDirectory()) {
            const children = createTree((0, path_1.join)(srcPath, file.name), (0, path_1.join)(outputPath, file.name), config);
            const exportDeclarations = [];
            const identifiers = [];
            for (const { identifierName, name } of children) {
                exportDeclarations.push((0, ast_1.createImportDeclaration)({ identifierName, iconName: name }));
                identifiers.push(identifierName);
            }
            exportDeclarations.push((0, ast_1.createArrayExport)(file.name, identifiers));
            const barrelFile = typescript_1.factory.updateSourceFile(sourceFile, exportDeclarations);
            tree.push(...children, {
                path: (0, path_1.join)(outputPath, file.name, `index.ts`),
                content: printer.printFile(barrelFile),
                identifierName: 'index',
                name: exports.INDEX
            });
        }
        else {
            if (file.name.endsWith('.svg')) {
                const iconName = (0, path_1.basename)(file.name, '.svg');
                const path = (0, path_1.join)(outputPath, file.name).replace('.svg', '.ts');
                const identifierName = resolveIdentifierName(iconName, config);
                const svgPath = (0, path_1.join)(srcPath, file.name);
                const svgContent = (0, fs_extra_1.readFileSync)(svgPath).toString();
                const statement = (0, ast_1.createStatement)({
                    svgContent: (0, svgo_1.optimize)(svgContent, { plugins, path: svgPath }).data,
                    iconName,
                    identifierName,
                });
                tree.push({
                    path,
                    content: printer.printNode(typescript_1.EmitHint.Unspecified, statement, sourceFile),
                    name: iconName,
                    identifierName
                });
            }
        }
    }
    return tree;
}
exports.createTree = createTree;
const invalidVariableCharsRegex = /[^a-zA-Z0-9_$]/g;
const startWithDigitRegex = /^[0-9]/;
const lettersRegex = /[a-zA-Z]/;
function resolveIdentifierName(iconName, config) {
    return (0, camelcase_1.default)([config.prefix, iconName, config.postfix])
        // Replace invalid characters with $ sign
        .replace(invalidVariableCharsRegex, config.invalidCharReplacer)
        // Ensure the first character is not a digit
        .replace(startWithDigitRegex, config.invalidCharReplacer)
        // Ensure the first letter is lowercase
        .replace(lettersRegex, (match) => match.toLowerCase());
}
exports.resolveIdentifierName = resolveIdentifierName;
