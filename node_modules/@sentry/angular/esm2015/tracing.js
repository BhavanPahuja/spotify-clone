import { Directive, Injectable, Input, NgModule } from '@angular/core';
// Duplicated import to work around a TypeScript bug where it'd complain that `Router` isn't imported as a type.
// We need to import it as a value to satisfy Angular dependency injection. So:
// eslint-disable-next-line @typescript-eslint/consistent-type-imports, import/no-duplicates
import { Router } from '@angular/router';
// eslint-disable-next-line import/no-duplicates
import { NavigationEnd, NavigationStart, ResolveEnd } from '@angular/router';
import { getCurrentHub, WINDOW } from '@sentry/browser';
import { logger, stripUrlQueryAndFragment, timestampInSeconds } from '@sentry/utils';
import { Subscription } from 'rxjs';
import { filter, tap } from 'rxjs/operators';
import { ANGULAR_INIT_OP, ANGULAR_OP, ANGULAR_ROUTING_OP } from './constants';
import { IS_DEBUG_BUILD } from './flags';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
let instrumentationInitialized;
let stashedStartTransaction;
let stashedStartTransactionOnLocationChange;
/**
 * Creates routing instrumentation for Angular Router.
 */
export function routingInstrumentation(customStartTransaction, startTransactionOnPageLoad = true, startTransactionOnLocationChange = true) {
    instrumentationInitialized = true;
    stashedStartTransaction = customStartTransaction;
    stashedStartTransactionOnLocationChange = startTransactionOnLocationChange;
    if (startTransactionOnPageLoad && WINDOW && WINDOW.location) {
        customStartTransaction({
            name: WINDOW.location.pathname,
            op: 'pageload',
            metadata: { source: 'url' },
        });
    }
}
export const instrumentAngularRouting = routingInstrumentation;
/**
 * Grabs active transaction off scope
 */
export function getActiveTransaction() {
    const currentHub = getCurrentHub();
    if (currentHub) {
        const scope = currentHub.getScope();
        if (scope) {
            return scope.getTransaction();
        }
    }
    return undefined;
}
/**
 * Angular's Service responsible for hooking into Angular Router and tracking current navigation process.
 * Creates a new transaction for every route change and measures a duration of routing process.
 */
export class TraceService {
    constructor(_router) {
        this._router = _router;
        this.navStart$ = this._router.events.pipe(filter((event) => event instanceof NavigationStart), tap(navigationEvent => {
            if (!instrumentationInitialized) {
                IS_DEBUG_BUILD &&
                    logger.error('Angular integration has tracing enabled, but Tracing integration is not configured');
                return;
            }
            const strippedUrl = stripUrlQueryAndFragment(navigationEvent.url);
            let activeTransaction = getActiveTransaction();
            if (!activeTransaction && stashedStartTransactionOnLocationChange) {
                activeTransaction = stashedStartTransaction({
                    name: strippedUrl,
                    op: 'navigation',
                    metadata: { source: 'url' },
                });
            }
            if (activeTransaction) {
                if (this._routingSpan) {
                    this._routingSpan.finish();
                }
                this._routingSpan = activeTransaction.startChild({
                    description: `${navigationEvent.url}`,
                    op: ANGULAR_ROUTING_OP,
                    tags: Object.assign({ 'routing.instrumentation': '@sentry/angular', url: strippedUrl }, (navigationEvent.navigationTrigger && {
                        navigationTrigger: navigationEvent.navigationTrigger,
                    })),
                });
            }
        }));
        // The ResolveEnd event is fired when the Angular router has resolved the URL and
        // the parameter<->value mapping. It holds the new resolved router state with
        // the mapping and the new URL.
        // Only After this event, the route is activated, meaning that the transaction
        // can be updated with the parameterized route name before e.g. the route's root
        // component is initialized. This should be early enough before outgoing requests
        // are made from the new route, with the exceptions of requests being made during
        // a navigation.
        this.resEnd$ = this._router.events.pipe(filter((event) => event instanceof ResolveEnd), tap(event => {
            const route = getParameterizedRouteFromSnapshot(event.state.root);
            const transaction = getActiveTransaction();
            // TODO (v8 / #5416): revisit the source condition. Do we want to make the parameterized route the default?
            if (transaction && transaction.metadata.source === 'url') {
                transaction.setName(route, 'route');
            }
        }));
        this.navEnd$ = this._router.events.pipe(filter(event => event instanceof NavigationEnd), tap(() => {
            if (this._routingSpan) {
                runOutsideAngular(() => {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    this._routingSpan.finish();
                });
                this._routingSpan = null;
            }
        }));
        this._routingSpan = null;
        this._subscription = new Subscription();
        this._subscription.add(this.navStart$.subscribe());
        this._subscription.add(this.resEnd$.subscribe());
        this._subscription.add(this.navEnd$.subscribe());
    }
    /**
     * This is used to prevent memory leaks when the root view is created and destroyed multiple times,
     * since `subscribe` callbacks capture `this` and prevent many resources from being GC'd.
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
}
TraceService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TraceService_Factory() { return new TraceService(i0.ɵɵinject(i1.Router)); }, token: TraceService, providedIn: "root" });
TraceService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
TraceService.ctorParameters = () => [
    { type: Router }
];
const UNKNOWN_COMPONENT = 'unknown';
/**
 * A directive that can be used to capture initialization lifecycle of the whole component.
 */
export class TraceDirective {
    /**
     * Implementation of OnInit lifecycle method
     * @inheritdoc
     */
    ngOnInit() {
        if (!this.componentName) {
            this.componentName = UNKNOWN_COMPONENT;
        }
        const activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            this._tracingSpan = activeTransaction.startChild({
                description: `<${this.componentName}>`,
                op: ANGULAR_INIT_OP,
            });
        }
    }
    /**
     * Implementation of AfterViewInit lifecycle method
     * @inheritdoc
     */
    ngAfterViewInit() {
        if (this._tracingSpan) {
            this._tracingSpan.finish();
        }
    }
}
TraceDirective.decorators = [
    { type: Directive, args: [{ selector: '[trace]' },] }
];
TraceDirective.propDecorators = {
    componentName: [{ type: Input, args: ['trace',] }]
};
/**
 * A module serves as a single compilation unit for the `TraceDirective` and can be re-used by any other module.
 */
export class TraceModule {
}
TraceModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TraceDirective],
                exports: [TraceDirective],
            },] }
];
/**
 * Decorator function that can be used to capture initialization lifecycle of the whole component.
 */
export function TraceClassDecorator() {
    let tracingSpan;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    return target => {
        const originalOnInit = target.prototype.ngOnInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngOnInit = function (...args) {
            const activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                tracingSpan = activeTransaction.startChild({
                    description: `<${target.name}>`,
                    op: ANGULAR_INIT_OP,
                });
            }
            if (originalOnInit) {
                return originalOnInit.apply(this, args);
            }
        };
        const originalAfterViewInit = target.prototype.ngAfterViewInit;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        target.prototype.ngAfterViewInit = function (...args) {
            if (tracingSpan) {
                tracingSpan.finish();
            }
            if (originalAfterViewInit) {
                return originalAfterViewInit.apply(this, args);
            }
        };
    };
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * Decorator function that can be used to capture a single lifecycle methods of the component.
 */
export function TraceMethodDecorator() {
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type, @typescript-eslint/ban-types
    return (target, propertyKey, descriptor) => {
        const originalMethod = descriptor.value;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        descriptor.value = function (...args) {
            const now = timestampInSeconds();
            const activeTransaction = getActiveTransaction();
            if (activeTransaction) {
                activeTransaction.startChild({
                    description: `<${target.constructor.name}>`,
                    endTimestamp: now,
                    op: `${ANGULAR_OP}.${String(propertyKey)}`,
                    startTimestamp: now,
                });
            }
            if (originalMethod) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalMethod.apply(this, args);
            }
        };
        return descriptor;
    };
}
/**
 * Takes the parameterized route from a given ActivatedRouteSnapshot and concatenates the snapshot's
 * child route with its parent to produce the complete parameterized URL of the activated route.
 * This happens recursively until the last child (i.e. the end of the URL) is reached.
 *
 * @param route the ActivatedRouteSnapshot of which its path and its child's path is concatenated
 *
 * @returns the concatenated parameterized route string
 */
export function getParameterizedRouteFromSnapshot(route) {
    const parts = [];
    let currentRoute = route && route.firstChild;
    while (currentRoute) {
        const path = currentRoute && currentRoute.routeConfig && currentRoute.routeConfig.path;
        if (path === null || path === undefined) {
            break;
        }
        parts.push(path);
        currentRoute = currentRoute.firstChild;
    }
    const fullPath = parts.filter(part => part).join('/');
    return fullPath ? `/${fullPath}/` : '/';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2luZy5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS9ydW5uZXIvd29yay9zZW50cnktamF2YXNjcmlwdC9zZW50cnktamF2YXNjcmlwdC9wYWNrYWdlcy9hbmd1bGFyL3NyYy8iLCJzb3VyY2VzIjpbInRyYWNpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2RSxnSEFBZ0g7QUFDaEgsK0VBQStFO0FBQy9FLDRGQUE0RjtBQUM1RixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekMsZ0RBQWdEO0FBQ2hELE9BQU8sRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzdFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFeEQsT0FBTyxFQUFFLE1BQU0sRUFBRSx3QkFBd0IsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVyRixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFN0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxVQUFVLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDOUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUN6QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxRQUFRLENBQUM7OztBQUUzQyxJQUFJLDBCQUFtQyxDQUFDO0FBQ3hDLElBQUksdUJBQWlGLENBQUM7QUFDdEYsSUFBSSx1Q0FBZ0QsQ0FBQztBQUVyRDs7R0FFRztBQUNILE1BQU0sVUFBVSxzQkFBc0IsQ0FDcEMsc0JBQWdGLEVBQ2hGLDZCQUFzQyxJQUFJLEVBQzFD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eEM7SUFFRCxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RELE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDMUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcyAqL1xuaW1wb3J0IHR5cGUgeyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbmplY3RhYmxlLCBJbnB1dCwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB0eXBlIHsgQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgRXZlbnQsIFJvdXRlclN0YXRlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbi8vIER1cGxpY2F0ZWQgaW1wb3J0IHRvIHdvcmsgYXJvdW5kIGEgVHlwZVNjcmlwdCBidWcgd2hlcmUgaXQnZCBjb21wbGFpbiB0aGF0IGBSb3V0ZXJgIGlzbid0IGltcG9ydGVkIGFzIGEgdHlwZS5cbi8vIFdlIG5lZWQgdG8gaW1wb3J0IGl0IGFzIGEgdmFsdWUgdG8gc2F0aXNmeSBBbmd1bGFyIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBTbzpcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWltcG9ydHMsIGltcG9ydC9uby1kdXBsaWNhdGVzXG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1kdXBsaWNhdGVzXG5pbXBvcnQgeyBOYXZpZ2F0aW9uRW5kLCBOYXZpZ2F0aW9uU3RhcnQsIFJlc29sdmVFbmQgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgZ2V0Q3VycmVudEh1YiwgV0lORE9XIH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCB0eXBlIHsgU3BhbiwgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uQ29udGV4dCB9IGZyb20gJ0BzZW50cnkvdHlwZXMnO1xuaW1wb3J0IHsgbG9nZ2VyLCBzdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQsIHRpbWVzdGFtcEluU2Vjb25kcyB9IGZyb20gJ0BzZW50cnkvdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBBTkdVTEFSX0lOSVRfT1AsIEFOR1VMQVJfT1AsIEFOR1VMQVJfUk9VVElOR19PUCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IElTX0RFQlVHX0JVSUxEIH0gZnJvbSAnLi9mbGFncyc7XG5pbXBvcnQgeyBydW5PdXRzaWRlQW5ndWxhciB9IGZyb20gJy4vem9uZSc7XG5cbmxldCBpbnN0cnVtZW50YXRpb25Jbml0aWFsaXplZDogYm9vbGVhbjtcbmxldCBzdGFzaGVkU3RhcnRUcmFuc2FjdGlvbjogKGNvbnRleHQ6IFRyYW5zYWN0aW9uQ29udGV4dCkgPT4gVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQ7XG5sZXQgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlOiBib29sZWFuO1xuXG4vKipcbiAqIENyZWF0ZXMgcm91dGluZyBpbnN0cnVtZW50YXRpb24gZm9yIEFuZ3VsYXIgUm91dGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91dGluZ0luc3RydW1lbnRhdGlvbihcbiAgY3VzdG9tU3RhcnRUcmFuc2FjdGlvbjogKGNvbnRleHQ6IFRyYW5zYWN0aW9uQ29udGV4dCkgPT4gVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQsXG4gIHN0YXJ0VHJhbnNhY3Rpb25PblBhZ2VMb2FkOiBib29sZWFuID0gdHJ1ZSxcbiAgc3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2U6IGJvb2xlYW4gPSB0cnVlLFxuKTogdm9pZCB7XG4gIGluc3RydW1lbnRhdGlvbkluaXRpYWxpemVkID0gdHJ1ZTtcbiAgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb24gPSBjdXN0b21TdGFydFRyYW5zYWN0aW9uO1xuICBzdGFzaGVkU3RhcnRUcmFuc2FjdGlvbk9uTG9jYXRpb25DaGFuZ2UgPSBzdGFydFRyYW5zYWN0aW9uT25Mb2NhdGlvbkNoYW5nZTtcblxuICBpZiAoc3RhcnRUcmFuc2FjdGlvbk9uUGFnZUxvYWQgJiYgV0lORE9XICYmIFdJTkRPVy5sb2NhdGlvbikge1xuICAgIGN1c3RvbVN0YXJ0VHJhbnNhY3Rpb24oe1xuICAgICAgbmFtZTogV0lORE9XLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgb3A6ICdwYWdlbG9hZCcsXG4gICAgICBtZXRhZGF0YTogeyBzb3VyY2U6ICd1cmwnIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGluc3RydW1lbnRBbmd1bGFyUm91dGluZyA9IHJvdXRpbmdJbnN0cnVtZW50YXRpb247XG5cbi8qKlxuICogR3JhYnMgYWN0aXZlIHRyYW5zYWN0aW9uIG9mZiBzY29wZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aXZlVHJhbnNhY3Rpb24oKTogVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQge1xuICBjb25zdCBjdXJyZW50SHViID0gZ2V0Q3VycmVudEh1YigpO1xuXG4gIGlmIChjdXJyZW50SHViKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBjdXJyZW50SHViLmdldFNjb3BlKCk7XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICByZXR1cm4gc2NvcGUuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEFuZ3VsYXIncyBTZXJ2aWNlIHJlc3BvbnNpYmxlIGZvciBob29raW5nIGludG8gQW5ndWxhciBSb3V0ZXIgYW5kIHRyYWNraW5nIGN1cnJlbnQgbmF2aWdhdGlvbiBwcm9jZXNzLlxuICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiBmb3IgZXZlcnkgcm91dGUgY2hhbmdlIGFuZCBtZWFzdXJlcyBhIGR1cmF0aW9uIG9mIHJvdXRpbmcgcHJvY2Vzcy5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBUcmFjZVNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwdWJsaWMgbmF2U3RhcnQkOiBPYnNlcnZhYmxlPEV2ZW50PiA9IHRoaXMuX3JvdXRlci5ldmVudHMucGlwZShcbiAgICBmaWx0ZXIoKGV2ZW50KTogZXZlbnQgaXMgTmF2aWdhdGlvblN0YXJ0ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvblN0YXJ0KSxcbiAgICB0YXAobmF2aWdhdGlvbkV2ZW50ID0+IHtcbiAgICAgIGlmICghaW5zdHJ1bWVudGF0aW9uSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgSVNfREVCVUdfQlVJTEQgJiZcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0FuZ3VsYXIgaW50ZWdyYXRpb24gaGFzIHRyYWNpbmcgZW5hYmxlZCwgYnV0IFRyYWNpbmcgaW50ZWdyYXRpb24gaXMgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdHJpcHBlZFVybCA9IHN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudChuYXZpZ2F0aW9uRXZlbnQudXJsKTtcbiAgICAgIGxldCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG5cbiAgICAgIGlmICghYWN0aXZlVHJhbnNhY3Rpb24gJiYgc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb25PbkxvY2F0aW9uQ2hhbmdlKSB7XG4gICAgICAgIGFjdGl2ZVRyYW5zYWN0aW9uID0gc3Rhc2hlZFN0YXJ0VHJhbnNhY3Rpb24oe1xuICAgICAgICAgIG5hbWU6IHN0cmlwcGVkVXJsLFxuICAgICAgICAgIG9wOiAnbmF2aWdhdGlvbicsXG4gICAgICAgICAgbWV0YWRhdGE6IHsgc291cmNlOiAndXJsJyB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZVRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3V0aW5nU3Bhbikge1xuICAgICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JvdXRpbmdTcGFuID0gYWN0aXZlVHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IGAke25hdmlnYXRpb25FdmVudC51cmx9YCxcbiAgICAgICAgICBvcDogQU5HVUxBUl9ST1VUSU5HX09QLFxuICAgICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICAgICdyb3V0aW5nLmluc3RydW1lbnRhdGlvbic6ICdAc2VudHJ5L2FuZ3VsYXInLFxuICAgICAgICAgICAgdXJsOiBzdHJpcHBlZFVybCxcbiAgICAgICAgICAgIC4uLihuYXZpZ2F0aW9uRXZlbnQubmF2aWdhdGlvblRyaWdnZXIgJiYge1xuICAgICAgICAgICAgICBuYXZpZ2F0aW9uVHJpZ2dlcjogbmF2aWdhdGlvbkV2ZW50Lm5hdmlnYXRpb25UcmlnZ2VyLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksXG4gICk7XG5cbiAgLy8gVGhlIFJlc29sdmVFbmQgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgQW5ndWxhciByb3V0ZXIgaGFzIHJlc29sdmVkIHRoZSBVUkwgYW5kXG4gIC8vIHRoZSBwYXJhbWV0ZXI8LT52YWx1ZSBtYXBwaW5nLiBJdCBob2xkcyB0aGUgbmV3IHJlc29sdmVkIHJvdXRlciBzdGF0ZSB3aXRoXG4gIC8vIHRoZSBtYXBwaW5nIGFuZCB0aGUgbmV3IFVSTC5cbiAgLy8gT25seSBBZnRlciB0aGlzIGV2ZW50LCB0aGUgcm91dGUgaXMgYWN0aXZhdGVkLCBtZWFuaW5nIHRoYXQgdGhlIHRyYW5zYWN0aW9uXG4gIC8vIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIHBhcmFtZXRlcml6ZWQgcm91dGUgbmFtZSBiZWZvcmUgZS5nLiB0aGUgcm91dGUncyByb290XG4gIC8vIGNvbXBvbmVudCBpcyBpbml0aWFsaXplZC4gVGhpcyBzaG91bGQgYmUgZWFybHkgZW5vdWdoIGJlZm9yZSBvdXRnb2luZyByZXF1ZXN0c1xuICAvLyBhcmUgbWFkZSBmcm9tIHRoZSBuZXcgcm91dGUsIHdpdGggdGhlIGV4Y2VwdGlvbnMgb2YgcmVxdWVzdHMgYmVpbmcgbWFkZSBkdXJpbmdcbiAgLy8gYSBuYXZpZ2F0aW9uLlxuICBwdWJsaWMgcmVzRW5kJDogT2JzZXJ2YWJsZTxFdmVudD4gPSB0aGlzLl9yb3V0ZXIuZXZlbnRzLnBpcGUoXG4gICAgZmlsdGVyKChldmVudCk6IGV2ZW50IGlzIFJlc29sdmVFbmQgPT4gZXZlbnQgaW5zdGFuY2VvZiBSZXNvbHZlRW5kKSxcbiAgICB0YXAoZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgcm91dGUgPSBnZXRQYXJhbWV0ZXJpemVkUm91dGVGcm9tU25hcHNob3QoXG4gICAgICAgIChldmVudC5zdGF0ZSBhcyB1bmtub3duIGFzIFJvdXRlclN0YXRlICYgeyByb290OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IH0pLnJvb3QsXG4gICAgICApO1xuXG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgICAvLyBUT0RPICh2OCAvICM1NDE2KTogcmV2aXNpdCB0aGUgc291cmNlIGNvbmRpdGlvbi4gRG8gd2Ugd2FudCB0byBtYWtlIHRoZSBwYXJhbWV0ZXJpemVkIHJvdXRlIHRoZSBkZWZhdWx0P1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uLm1ldGFkYXRhLnNvdXJjZSA9PT0gJ3VybCcpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc2V0TmFtZShyb3V0ZSwgJ3JvdXRlJyk7XG4gICAgICB9XG4gICAgfSksXG4gICk7XG5cbiAgcHVibGljIG5hdkVuZCQ6IE9ic2VydmFibGU8RXZlbnQ+ID0gdGhpcy5fcm91dGVyLmV2ZW50cy5waXBlKFxuICAgIGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpLFxuICAgIHRhcCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcm91dGluZ1NwYW4pIHtcbiAgICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4hLmZpbmlzaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcm91dGluZ1NwYW4gPSBudWxsO1xuICAgICAgfVxuICAgIH0pLFxuICApO1xuXG4gIHByaXZhdGUgX3JvdXRpbmdTcGFuOiBTcGFuIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgX3JvdXRlcjogUm91dGVyKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLm5hdlN0YXJ0JC5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLnJlc0VuZCQuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQodGhpcy5uYXZFbmQkLnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgd2hlbiB0aGUgcm9vdCB2aWV3IGlzIGNyZWF0ZWQgYW5kIGRlc3Ryb3llZCBtdWx0aXBsZSB0aW1lcyxcbiAgICogc2luY2UgYHN1YnNjcmliZWAgY2FsbGJhY2tzIGNhcHR1cmUgYHRoaXNgIGFuZCBwcmV2ZW50IG1hbnkgcmVzb3VyY2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICovXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuXG5jb25zdCBVTktOT1dOX0NPTVBPTkVOVCA9ICd1bmtub3duJztcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhcHR1cmUgaW5pdGlhbGl6YXRpb24gbGlmZWN5Y2xlIG9mIHRoZSB3aG9sZSBjb21wb25lbnQuXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1t0cmFjZV0nIH0pXG5leHBvcnQgY2xhc3MgVHJhY2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQge1xuICBASW5wdXQoJ3RyYWNlJykgcHVibGljIGNvbXBvbmVudE5hbWU/OiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBfdHJhY2luZ1NwYW4/OiBTcGFuO1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBPbkluaXQgbGlmZWN5Y2xlIG1ldGhvZFxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jb21wb25lbnROYW1lKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudE5hbWUgPSBVTktOT1dOX0NPTVBPTkVOVDtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKGFjdGl2ZVRyYW5zYWN0aW9uKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICBkZXNjcmlwdGlvbjogYDwke3RoaXMuY29tcG9uZW50TmFtZX0+YCxcbiAgICAgICAgb3A6IEFOR1VMQVJfSU5JVF9PUCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBBZnRlclZpZXdJbml0IGxpZmVjeWNsZSBtZXRob2RcbiAgICogQGluaGVyaXRkb2NcbiAgICovXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3RyYWNpbmdTcGFuKSB7XG4gICAgICB0aGlzLl90cmFjaW5nU3Bhbi5maW5pc2goKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIG1vZHVsZSBzZXJ2ZXMgYXMgYSBzaW5nbGUgY29tcGlsYXRpb24gdW5pdCBmb3IgdGhlIGBUcmFjZURpcmVjdGl2ZWAgYW5kIGNhbiBiZSByZS11c2VkIGJ5IGFueSBvdGhlciBtb2R1bGUuXG4gKi9cbkBOZ01vZHVsZSh7XG4gIGRlY2xhcmF0aW9uczogW1RyYWNlRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1RyYWNlRGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHJhY2VNb2R1bGUge31cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGluaXRpYWxpemF0aW9uIGxpZmVjeWNsZSBvZiB0aGUgd2hvbGUgY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gVHJhY2VDbGFzc0RlY29yYXRvcigpOiBDbGFzc0RlY29yYXRvciB7XG4gIGxldCB0cmFjaW5nU3BhbjogU3BhbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1mdW5jdGlvbi1yZXR1cm4tdHlwZVxuICByZXR1cm4gdGFyZ2V0ID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbE9uSW5pdCA9IHRhcmdldC5wcm90b3R5cGUubmdPbkluaXQ7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICB0YXJnZXQucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxPbkluaXQ+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZVRyYW5zYWN0aW9uID0gZ2V0QWN0aXZlVHJhbnNhY3Rpb24oKTtcbiAgICAgIGlmIChhY3RpdmVUcmFuc2FjdGlvbikge1xuICAgICAgICB0cmFjaW5nU3BhbiA9IGFjdGl2ZVRyYW5zYWN0aW9uLnN0YXJ0Q2hpbGQoe1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgPCR7dGFyZ2V0Lm5hbWV9PmAsXG4gICAgICAgICAgb3A6IEFOR1VMQVJfSU5JVF9PUCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxPbkluaXQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT25Jbml0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvcmlnaW5hbEFmdGVyVmlld0luaXQgPSB0YXJnZXQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHRhcmdldC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKC4uLmFyZ3M6IGFueVtdKTogUmV0dXJuVHlwZTx0eXBlb2Ygb3JpZ2luYWxBZnRlclZpZXdJbml0PiB7XG4gICAgICBpZiAodHJhY2luZ1NwYW4pIHtcbiAgICAgICAgdHJhY2luZ1NwYW4uZmluaXNoKCk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxBZnRlclZpZXdJbml0KSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEFmdGVyVmlld0luaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MgKi9cbn1cblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIGEgc2luZ2xlIGxpZmVjeWNsZSBtZXRob2RzIG9mIHRoZSBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBUcmFjZU1ldGhvZERlY29yYXRvcigpOiBNZXRob2REZWNvcmF0b3Ige1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LWZ1bmN0aW9uLXJldHVybi10eXBlLCBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gIHJldHVybiAodGFyZ2V0OiBPYmplY3QsIHByb3BlcnR5S2V5OiBzdHJpbmcgfCBzeW1ib2wsIGRlc2NyaXB0b3I6IFByb3BlcnR5RGVzY3JpcHRvcikgPT4ge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pOiBSZXR1cm5UeXBlPHR5cGVvZiBvcmlnaW5hbE1ldGhvZD4ge1xuICAgICAgY29uc3Qgbm93ID0gdGltZXN0YW1wSW5TZWNvbmRzKCk7XG4gICAgICBjb25zdCBhY3RpdmVUcmFuc2FjdGlvbiA9IGdldEFjdGl2ZVRyYW5zYWN0aW9uKCk7XG4gICAgICBpZiAoYWN0aXZlVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgYWN0aXZlVHJhbnNhY3Rpb24uc3RhcnRDaGlsZCh7XG4gICAgICAgICAgZGVzY3JpcHRpb246IGA8JHt0YXJnZXQuY29uc3RydWN0b3IubmFtZX0+YCxcbiAgICAgICAgICBlbmRUaW1lc3RhbXA6IG5vdyxcbiAgICAgICAgICBvcDogYCR7QU5HVUxBUl9PUH0uJHtTdHJpbmcocHJvcGVydHlLZXkpfWAsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXA6IG5vdyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWxNZXRob2QpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgcGFyYW1ldGVyaXplZCByb3V0ZSBmcm9tIGEgZ2l2ZW4gQWN0aXZhdGVkUm91dGVTbmFwc2hvdCBhbmQgY29uY2F0ZW5hdGVzIHRoZSBzbmFwc2hvdCdzXG4gKiBjaGlsZCByb3V0ZSB3aXRoIGl0cyBwYXJlbnQgdG8gcHJvZHVjZSB0aGUgY29tcGxldGUgcGFyYW1ldGVyaXplZCBVUkwgb2YgdGhlIGFjdGl2YXRlZCByb3V0ZS5cbiAqIFRoaXMgaGFwcGVucyByZWN1cnNpdmVseSB1bnRpbCB0aGUgbGFzdCBjaGlsZCAoaS5lLiB0aGUgZW5kIG9mIHRoZSBVUkwpIGlzIHJlYWNoZWQuXG4gKlxuICogQHBhcmFtIHJvdXRlIHRoZSBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90IG9mIHdoaWNoIGl0cyBwYXRoIGFuZCBpdHMgY2hpbGQncyBwYXRoIGlzIGNvbmNhdGVuYXRlZFxuICpcbiAqIEByZXR1cm5zIHRoZSBjb25jYXRlbmF0ZWQgcGFyYW1ldGVyaXplZCByb3V0ZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtZXRlcml6ZWRSb3V0ZUZyb21TbmFwc2hvdChyb3V0ZT86IEFjdGl2YXRlZFJvdXRlU25hcHNob3QgfCBudWxsKTogc3RyaW5nIHtcbiAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gW107XG5cbiAgbGV0IGN1cnJlbnRSb3V0ZSA9IHJvdXRlICYmIHJvdXRlLmZpcnN0Q2hpbGQ7XG4gIHdoaWxlIChjdXJyZW50Um91dGUpIHtcbiAgICBjb25zdCBwYXRoID0gY3VycmVudFJvdXRlICYmIGN1cnJlbnRSb3V0ZS5yb3V0ZUNvbmZpZyAmJiBjdXJyZW50Um91dGUucm91dGVDb25maWcucGF0aDtcbiAgICBpZiAocGF0aCA9PT0gbnVsbCB8fCBwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2gocGF0aCk7XG4gICAgY3VycmVudFJvdXRlID0gY3VycmVudFJvdXRlLmZpcnN0Q2hpbGQ7XG4gIH1cblxuICBjb25zdCBmdWxsUGF0aCA9IHBhcnRzLmZpbHRlcihwYXJ0ID0+IHBhcnQpLmpvaW4oJy8nKTtcbiAgcmV0dXJuIGZ1bGxQYXRoID8gYC8ke2Z1bGxQYXRofS9gIDogJy8nO1xufVxuIl19