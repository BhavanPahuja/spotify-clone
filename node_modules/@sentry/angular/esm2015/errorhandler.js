import { HttpErrorResponse } from '@angular/common/http';
import { Inject, Injectable } from '@angular/core';
import * as Sentry from '@sentry/browser';
import { captureException } from '@sentry/browser';
import { addExceptionMechanism, isString } from '@sentry/utils';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
// https://github.com/angular/angular/blob/master/packages/core/src/util/errors.ts
function tryToUnwrapZonejsError(error) {
    // TODO: once Angular14 is the minimum requirement ERROR_ORIGINAL_ERROR and
    //  getOriginalError from error.ts can be used directly.
    return error && error.ngOriginalError
        ? error.ngOriginalError
        : error;
}
function extractHttpModuleError(error) {
    // The `error` property of http exception can be either an `Error` object, which we can use directly...
    if (isErrorOrErrorLikeObject(error.error)) {
        return error.error;
    }
    // ... or an`ErrorEvent`, which can provide us with the message but no stack...
    if (error.error instanceof ErrorEvent && error.error.message) {
        return error.error.message;
    }
    // ...or the request body itself, which we can use as a message instead.
    if (typeof error.error === 'string') {
        return `Server returned code ${error.status} with body "${error.error}"`;
    }
    // If we don't have any detailed information, fallback to the request message itself.
    return error.message;
}
function isErrorOrErrorLikeObject(value) {
    if (value instanceof Error) {
        return true;
    }
    if (value === null || typeof value !== 'object') {
        return false;
    }
    const candidate = value;
    return (isString(candidate.name) &&
        isString(candidate.name) &&
        isString(candidate.message) &&
        (undefined === candidate.stack || isString(candidate.stack)));
}
/**
 * Implementation of Angular's ErrorHandler provider that can be used as a drop-in replacement for the stock one.
 */
class SentryErrorHandler {
    constructor(options) {
        /* indicates if we already registered our the afterSendEvent handler */
        this._registeredAfterSendEventHandler = false;
        this._options = Object.assign({ logErrors: true }, options);
    }
    /**
     * Method called for every value captured through the ErrorHandler
     */
    handleError(error) {
        const extractedError = this._extractError(error) || 'Handled unknown error';
        // Capture handled exception and send it to Sentry.
        const eventId = runOutsideAngular(() => captureException(extractedError, scope => {
            scope.addEventProcessor(event => {
                addExceptionMechanism(event, {
                    type: 'angular',
                    handled: false,
                });
                return event;
            });
            return scope;
        }));
        // When in development mode, log the error to console for immediate feedback.
        if (this._options.logErrors) {
            // eslint-disable-next-line no-console
            console.error(extractedError);
        }
        // Optionally show user dialog to provide details on what happened.
        if (this._options.showDialog) {
            const client = Sentry.getCurrentHub().getClient();
            if (client && client.on && !this._registeredAfterSendEventHandler) {
                client.on('afterSendEvent', event => {
                    if (!event.type) {
                        Sentry.showReportDialog(Object.assign(Object.assign({}, this._options.dialogOptions), { eventId: event.event_id }));
                    }
                });
                // We only want to register this hook once in the lifetime of the error handler
                this._registeredAfterSendEventHandler = true;
            }
            else if (!client || !client.on) {
                Sentry.showReportDialog(Object.assign(Object.assign({}, this._options.dialogOptions), { eventId }));
            }
        }
    }
    /**
     * Used to pull a desired value that will be used to capture an event out of the raw value captured by ErrorHandler.
     */
    _extractError(error) {
        // Allow custom overrides of extracting function
        if (this._options.extractor) {
            const defaultExtractor = this._defaultExtractor.bind(this);
            return this._options.extractor(error, defaultExtractor);
        }
        return this._defaultExtractor(error);
    }
    /**
     * Default implementation of error extraction that handles default error wrapping, HTTP responses, ErrorEvent and few other known cases.
     */
    _defaultExtractor(errorCandidate) {
        const error = tryToUnwrapZonejsError(errorCandidate);
        // If it's http module error, extract as much information from it as we can.
        if (error instanceof HttpErrorResponse) {
            return extractHttpModuleError(error);
        }
        // We can handle messages and Error objects directly.
        if (typeof error === 'string' || isErrorOrErrorLikeObject(error)) {
            return error;
        }
        // Nothing was extracted, fallback to default error message.
        return null;
    }
}
SentryErrorHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function SentryErrorHandler_Factory() { return new SentryErrorHandler(i0.ɵɵinject("errorHandlerOptions")); }, token: SentryErrorHandler, providedIn: "root" });
SentryErrorHandler.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
SentryErrorHandler.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['errorHandlerOptions',] }] }
];
/**
 * Factory function that creates an instance of a preconfigured ErrorHandler provider.
 */
function createErrorHandler(config) {
    return new SentryErrorHandler(config);
}
export { createErrorHandler, SentryErrorHandler };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JoYW5kbGVyLmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3J1bm5lci93b3JrL3NlbnRyeS1qYXZhc2NyaXB0L3NlbnRyeS1qYXZhc2NyaXB0L3BhY2thZ2VzL2FuZ3VsYXIvc3JjLyIsInNvdXJjZXMiOlsiZXJyb3JoYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpELE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sS0FBSyxNQUFNLE1BQU0saUJBQWlCLENBQUM7QUFDMUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVoRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxRQUFRLENBQUM7O0FBaUIzQyxrRkFBa0Y7QUFDbEYsU0FBUyxzQkFBc0IsQ0FBQyxLQUFjO0lBQzVDLDJFQUEyRTtJQUMzRSx3REFBd0Q7SUFDeEQsT0FBTyxLQUFLLElBQUssS0FBb0MsQ0FBQyxlQUFlO1FBQ25FLENBQUMsQ0FBRSxLQUFvQyxDQUFDLGVBQWU7UUFDdkQsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUM7QUFFRCxTQUFTLHNCQUFzQixDQUFDLEtBQXdCO0lBQ3RELHVHQUF1RztJQUN2RyxJQUFJLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN6QyxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUM7S0FDcEI7SUFFRCwrRUFBK0U7SUFDL0UsSUFBSSxLQUFLLENBQUMsS0FBSyxZQUFZLFVBQVUsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRTtRQUM1RCxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDO0tBQzVCO0lBRUQsd0VBQXdFO0lB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b3J0IHsgSHR0cEVycm9yUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgdHlwZSB7IEVycm9ySGFuZGxlciBhcyBBbmd1bGFyRXJyb3JIYW5kbGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIFNlbnRyeSBmcm9tICdAc2VudHJ5L2Jyb3dzZXInO1xuaW1wb3J0IHsgY2FwdHVyZUV4Y2VwdGlvbiB9IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XG5pbXBvcnQgeyBhZGRFeGNlcHRpb25NZWNoYW5pc20sIGlzU3RyaW5nIH0gZnJvbSAnQHNlbnRyeS91dGlscyc7XG5cbmltcG9ydCB7IHJ1bk91dHNpZGVBbmd1bGFyIH0gZnJvbSAnLi96b25lJztcblxuLyoqXG4gKiBPcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoZSBiZWhhdmlvciBvZiB0aGUgQW5ndWxhciBFcnJvckhhbmRsZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JIYW5kbGVyT3B0aW9ucyB7XG4gIGxvZ0Vycm9ycz86IGJvb2xlYW47XG4gIHNob3dEaWFsb2c/OiBib29sZWFuO1xuICBkaWFsb2dPcHRpb25zPzogU2VudHJ5LlJlcG9ydERpYWxvZ09wdGlvbnM7XG4gIC8qKlxuICAgKiBDdXN0b20gaW1wbGVtZW50YXRpb24gb2YgZXJyb3IgZXh0cmFjdGlvbiBmcm9tIHRoZSByYXcgdmFsdWUgY2FwdHVyZWQgYnkgdGhlIEFuZ3VsYXIuXG4gICAqIEBwYXJhbSBlcnJvciBWYWx1ZSBjYXB0dXJlZCBieSBBbmd1bGFyJ3MgRXJyb3JIYW5kbGVyIHByb3ZpZGVyXG4gICAqIEBwYXJhbSBkZWZhdWx0RXh0cmFjdG9yIERlZmF1bHQgaW1wbGVtZW50YXRpb24gdGhhdCBjYW4gYmUgdXNlZCBhcyB0aGUgZmFsbGJhY2sgaW4gY2FzZSBvZiBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICovXG4gIGV4dHJhY3Rvcj8oZXJyb3I6IHVua25vd24sIGRlZmF1bHRFeHRyYWN0b3I6IChlcnJvcjogdW5rbm93bikgPT4gdW5rbm93bik6IHVua25vd247XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9tYXN0ZXIvcGFja2FnZXMvY29yZS9zcmMvdXRpbC9lcnJvcnMudHNcbmZ1bmN0aW9uIHRyeVRvVW53cmFwWm9uZWpzRXJyb3IoZXJyb3I6IHVua25vd24pOiB1bmtub3duIHwgRXJyb3Ige1xuICAvLyBUT0RPOiBvbmNlIEFuZ3VsYXIxNCBpcyB0aGUgbWluaW11bSByZXF1aXJlbWVudCBFUlJPUl9PUklHSU5BTF9FUlJPUiBhbmRcbiAgLy8gIGdldE9yaWdpbmFsRXJyb3IgZnJvbSBlcnJvci50cyBjYW4gYmUgdXNlZCBkaXJlY3RseS5cbiAgcmV0dXJuIGVycm9yICYmIChlcnJvciBhcyB7IG5nT3JpZ2luYWxFcnJvcjogRXJyb3IgfSkubmdPcmlnaW5hbEVycm9yXG4gICAgPyAoZXJyb3IgYXMgeyBuZ09yaWdpbmFsRXJyb3I6IEVycm9yIH0pLm5nT3JpZ2luYWxFcnJvclxuICAgIDogZXJyb3I7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RIdHRwTW9kdWxlRXJyb3IoZXJyb3I6IEh0dHBFcnJvclJlc3BvbnNlKTogc3RyaW5nIHwgRXJyb3Ige1xuICAvLyBUaGUgYGVycm9yYCBwcm9wZXJ0eSBvZiBodHRwIGV4Y2VwdGlvbiBjYW4gYmUgZWl0aGVyIGFuIGBFcnJvcmAgb2JqZWN0LCB3aGljaCB3ZSBjYW4gdXNlIGRpcmVjdGx5Li4uXG4gIGlmIChpc0Vycm9yT3JFcnJvckxpa2VPYmplY3QoZXJyb3IuZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yLmVycm9yO1xuICB9XG5cbiAgLy8gLi4uIG9yIGFuYEVycm9yRXZlbnRgLCB3aGljaCBjYW4gcHJvdmlkZSB1cyB3aXRoIHRoZSBtZXNzYWdlIGJ1dCBubyBzdGFjay4uLlxuICBpZiAoZXJyb3IuZXJyb3IgaW5zdGFuY2VvZiBFcnJvckV2ZW50ICYmIGVycm9yLmVycm9yLm1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZXJyb3IuZXJyb3IubWVzc2FnZTtcbiAgfVxuXG4gIC8vIC4uLm9yIHRoZSByZXF1ZXN0IGJvZHkgaXRzZWxmLCB3aGljaCB3ZSBjYW4gdXNlIGFzIGEgbWVzc2FnZSBpbnN0ZWFkLlxuICBpZiAodHlwZW9mIGVycm9yLmVycm9yID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBgU2VydmVyIHJldHVybmVkIGNvZGUgJHtlcnJvci5zdGF0dXN9IHdpdGggYm9keSBcIiR7ZXJyb3IuZXJyb3J9XCJgO1xuICB9XG5cbiAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgZGV0YWlsZWQgaW5mb3JtYXRpb24sIGZhbGxiYWNrIHRvIHRoZSByZXF1ZXN0IG1lc3NhZ2UgaXRzZWxmLlxuICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbn1cblxudHlwZSBFcnJvckNhbmRpZGF0ZSA9IHtcbiAgbmFtZT86IHVua25vd247XG4gIG1lc3NhZ2U/OiB1bmtub3duO1xuICBzdGFjaz86IHVua25vd247XG59O1xuXG5mdW5jdGlvbiBpc0Vycm9yT3JFcnJvckxpa2VPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBFcnJvciB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlIGFzIEVycm9yQ2FuZGlkYXRlO1xuXG4gIHJldHVybiAoXG4gICAgaXNTdHJpbmcoY2FuZGlkYXRlLm5hbWUpICYmXG4gICAgaXNTdHJpbmcoY2FuZGlkYXRlLm5hbWUpICYmXG4gICAgaXNTdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpICYmXG4gICAgKHVuZGVmaW5lZCA9PT0gY2FuZGlkYXRlLnN0YWNrIHx8IGlzU3RyaW5nKGNhbmRpZGF0ZS5zdGFjaykpXG4gICk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgQW5ndWxhcidzIEVycm9ySGFuZGxlciBwcm92aWRlciB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlIHN0b2NrIG9uZS5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmNsYXNzIFNlbnRyeUVycm9ySGFuZGxlciBpbXBsZW1lbnRzIEFuZ3VsYXJFcnJvckhhbmRsZXIge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX29wdGlvbnM6IEVycm9ySGFuZGxlck9wdGlvbnM7XG5cbiAgLyogaW5kaWNhdGVzIGlmIHdlIGFscmVhZHkgcmVnaXN0ZXJlZCBvdXIgdGhlIGFmdGVyU2VuZEV2ZW50IGhhbmRsZXIgKi9cbiAgcHJpdmF0ZSBfcmVnaXN0ZXJlZEFmdGVyU2VuZEV2ZW50SGFuZGxlciA9IGZhbHNlO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihASW5qZWN0KCdlcnJvckhhbmRsZXJPcHRpb25zJykgb3B0aW9ucz86IEVycm9ySGFuZGxlck9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgbG9nRXJyb3JzOiB0cnVlLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBjYWxsZWQgZm9yIGV2ZXJ5IHZhbHVlIGNhcHR1cmVkIHRocm91Z2ggdGhlIEVycm9ySGFuZGxlclxuICAgKi9cbiAgcHVibGljIGhhbmRsZUVycm9yKGVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gICAgY29uc3QgZXh0cmFjdGVkRXJyb3IgPSB0aGlzLl9leHRyYWN0RXJyb3IoZXJyb3IpIHx8ICdIYW5kbGVkIHVua25vd24gZXJyb3InO1xuXG4gICAgLy8gQ2FwdHVyZSBoYW5kbGVkIGV4Y2VwdGlvbiBhbmQgc2VuZCBpdCB0byBTZW50cnkuXG4gICAgY29uc3QgZXZlbnRJZCA9IHJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICBjYXB0dXJlRXhjZXB0aW9uKGV4dHJhY3RlZEVycm9yLCBzY29wZSA9PiB7XG4gICAgICAgIHNjb3BlLmFkZEV2ZW50UHJvY2Vzc29yKGV2ZW50ID0+IHtcbiAgICAgICAgICBhZGRFeGNlcHRpb25NZWNoYW5pc20oZXZlbnQsIHtcbiAgICAgICAgICAgIHR5cGU6ICdhbmd1bGFyJyxcbiAgICAgICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgLy8gV2hlbiBpbiBkZXZlbG9wbWVudCBtb2RlLCBsb2cgdGhlIGVycm9yIHRvIGNvbnNvbGUgZm9yIGltbWVkaWF0ZSBmZWVkYmFjay5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5sb2dFcnJvcnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKGV4dHJhY3RlZEVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5IHNob3cgdXNlciBkaWFsb2cgdG8gcHJvdmlkZSBkZXRhaWxzIG9uIHdoYXQgaGFwcGVuZWQuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd0RpYWxvZykge1xuICAgICAgY29uc3QgY2xpZW50ID0gU2VudHJ5LmdldEN1cnJlbnRIdWIoKS5nZXRDbGllbnQoKTtcblxuICAgICAgaWYgKGNsaWVudCAmJiBjbGllbnQub24gJiYgIXRoaXMuX3JlZ2lzdGVyZWRBZnRlclNlbmRFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgY2xpZW50Lm9uKCdhZnRlclNlbmRFdmVudCcsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIFNlbnRyeS5zaG93UmVwb3J0RGlhbG9nKHsgLi4udGhpcy5fb3B0aW9ucy5kaWFsb2dPcHRpb25zLCBldmVudElkOiBldmVudC5ldmVudF9pZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byByZWdpc3RlciB0aGlzIGhvb2sgb25jZSBpbiB0aGUgbGlmZXRpbWUgb2YgdGhlIGVycm9yIGhhbmRsZXJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZEFmdGVyU2VuZEV2ZW50SGFuZGxlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFjbGllbnQgfHwgIWNsaWVudC5vbikge1xuICAgICAgICBTZW50cnkuc2hvd1JlcG9ydERpYWxvZyh7IC4uLnRoaXMuX29wdGlvbnMuZGlhbG9nT3B0aW9ucywgZXZlbnRJZCB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBwdWxsIGEgZGVzaXJlZCB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBjYXB0dXJlIGFuIGV2ZW50IG91dCBvZiB0aGUgcmF3IHZhbHVlIGNhcHR1cmVkIGJ5IEVycm9ySGFuZGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBfZXh0cmFjdEVycm9yKGVycm9yOiB1bmtub3duKTogdW5rbm93biB7XG4gICAgLy8gQWxsb3cgY3VzdG9tIG92ZXJyaWRlcyBvZiBleHRyYWN0aW5nIGZ1bmN0aW9uXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZXh0cmFjdG9yKSB7XG4gICAgICBjb25zdCBkZWZhdWx0RXh0cmFjdG9yID0gdGhpcy5fZGVmYXVsdEV4dHJhY3Rvci5iaW5kKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZXh0cmFjdG9yKGVycm9yLCBkZWZhdWx0RXh0cmFjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEV4dHJhY3RvcihlcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBlcnJvciBleHRyYWN0aW9uIHRoYXQgaGFuZGxlcyBkZWZhdWx0IGVycm9yIHdyYXBwaW5nLCBIVFRQIHJlc3BvbnNlcywgRXJyb3JFdmVudCBhbmQgZmV3IG90aGVyIGtub3duIGNhc2VzLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9kZWZhdWx0RXh0cmFjdG9yKGVycm9yQ2FuZGlkYXRlOiB1bmtub3duKTogdW5rbm93biB7XG4gICAgY29uc3QgZXJyb3IgPSB0cnlUb1Vud3JhcFpvbmVqc0Vycm9yKGVycm9yQ2FuZGlkYXRlKTtcblxuICAgIC8vIElmIGl0J3MgaHR0cCBtb2R1bGUgZXJyb3IsIGV4dHJhY3QgYXMgbXVjaCBpbmZvcm1hdGlvbiBmcm9tIGl0IGFzIHdlIGNhbi5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBIdHRwRXJyb3JSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RIdHRwTW9kdWxlRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbiBoYW5kbGUgbWVzc2FnZXMgYW5kIEVycm9yIG9iamVjdHMgZGlyZWN0bHkuXG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgfHwgaXNFcnJvck9yRXJyb3JMaWtlT2JqZWN0KGVycm9yKSkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIE5vdGhpbmcgd2FzIGV4dHJhY3RlZCwgZmFsbGJhY2sgdG8gZGVmYXVsdCBlcnJvciBtZXNzYWdlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBwcmVjb25maWd1cmVkIEVycm9ySGFuZGxlciBwcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JIYW5kbGVyKGNvbmZpZz86IEVycm9ySGFuZGxlck9wdGlvbnMpOiBTZW50cnlFcnJvckhhbmRsZXIge1xuICByZXR1cm4gbmV3IFNlbnRyeUVycm9ySGFuZGxlcihjb25maWcpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFcnJvckhhbmRsZXIsIFNlbnRyeUVycm9ySGFuZGxlciB9O1xuIl19